__author__ = "Alexandre Florio, Maximilian Schiffer, Pedro Martins, Thiago Serra, and Thibaut Vidal"

import time
from gurobipy import *
from solution import Solution
import config as cfg

best_solution_val = None
wall_time_of_solution = None

solver_optimal = 0
solver_timeout_with_sol = 0
solver_timeout_no_sol = 0
solver_infeasible = 0

class Optimizer:
    """
    Implements the mixed-integer linear programming (MILP) formulation for decision diagrams using Gurobi.

    .. note:: The Optimizer configuration can be found in the global :py:mod:`config` module, including the solver's 
       time limit, tolerance and verbosity.

    Parameters
    ----------
    data : Dataset
        Dataset instance to be used for building the diagram.
    topology : Topology
        Topology instance to be used for building the diagram.
    alpha : float, default 0.0
        Alpha hyperparameter for controlling model complexity. Should be a number between 0.0 and 1.0.
    initial_solution : Solution or None, default None
        If not None, provides the model with a cutoff at the initial solution's objective value (adjusted up by 1%).
    univariate_split : bool, default False
        Flag for using univariate or multivariate splits. If True, a single feature is used for each split, resulting in 
        an *axis-aligned* diagram. If False, multiple features can be used for defining the splitting hyperplane, resulting in
        an *oblique* diagram.
    sym_break : bool, default True
        Flag for using symmetry-breaking constraints. Without any constraint for breaking symmetry, :math:`2^{|V_I|}` equivalent
        topologies can be obtained by switching the positive- and negative-side arcs of each internal node and using opposite 
        hyperplanes, where :math:`V_I` is the set internal nodes for a diagram. Such symmetry has a dramatic negative impact 
        on branch-and-bound-based MILP solution approaches. If `sym_break` is True, constraints are added to fix the order of arcs 
        between nodes and restrict certain arcs, reducing the number of equivalent topologies.
    force_tree : bool, default False
        If True, the formulation design variables are forced to conform to a tree (i.e. merges are disallowed). This parameter can be
        used for constructing *optimal decision trees*.

    Attributes
    ----------
    solution : Solution
        The decision diagram Solution instance generated by the MILP formulation.
    """

    def __init__(self, data, topology, alpha=0.0, initial_solution=None, univariate_split=False, sym_break=True,
                 force_tree=False):
        global solver_optimal, solver_timeout_with_sol, solver_timeout_no_sol, solver_infeasible
        start_time = time.time()

        # data structures for indexing the decision variables
        sample_terminal_pairs = [(i, v) for i in range(data.train_n)
                for v in topology.nodes_per_layer[topology.layers-1]]
        sample_nonterminal_pairs = [(i, v) for i in range(data.train_n)
                for l in range(topology.layers-1) for v in topology.nodes_per_layer[l]]
        sample_arc_tuples = [(i,s,u,v) for i in range(data.train_n) for (s,u,v) in topology.arcs]
        sample_layer_pairs = [(i,l) for i in range(data.train_n) for l in range(topology.layers)]

        # dictionary for the cost per assignment of classification graph obtained
        assignment_cost = {}
        for (i, v) in sample_terminal_pairs:
            if topology.node_class[v] == data.train_Y[i]:
                assignment_cost[(i,v)] = 0
            else:
                assignment_cost[(i,v)] = 1

        # construct model and optimize it
        with gurobipy.Model() as model:

            # odd design/layout d.v.'s
            d = model.addVars(topology.nodes, lb=0.0, ub=1.0)
            y = model.addVars(topology.arcs, vtype=GRB.BINARY)

            # sample flow d.v.'s
            w_t = model.addVars(sample_terminal_pairs, lb=0.0, ub=1.0)
            w_p = model.addVars(sample_nonterminal_pairs, lb=0.0, ub=1.0)
            w_n = model.addVars(sample_nonterminal_pairs, lb=0.0, ub=1.0)
            z = model.addVars(sample_arc_tuples, lb=0.0, ub=1.0)
            lambda_var = model.addVars(sample_layer_pairs, vtype=GRB.BINARY)

            a = {}
            ap = {}
            an = {}
            b = {}
            for u in topology.nonterminal_nodes:
                ap[u] = model.addVars(data.features, lb=0.0, ub=1.0)
                an[u] = model.addVars(data.features, lb=0.0, ub=1.0)
                if univariate_split:
                    a[u] = model.addVars(data.features, vtype=GRB.INTEGER, lb=-1, ub=1)
                    model.addConstr(gurobipy.quicksum(ap[u][f]+an[u][f] for f in data.features)==1)
                else:
                    a[u] = model.addVars(data.features, lb=-1.0, ub=1.0)
                    model.addConstr(gurobipy.quicksum(ap[u][f]+an[u][f] for f in data.features)<=1)
                for f in data.features:
                    model.addConstr(a[u][f] == ap[u][f]-an[u][f])
                b[u] = model.addVar(lb=-1.0, ub=1.0)

            # force root node to be used
            model.addConstr(d[topology.root_node] == 1)

            # force terminal nodes to be used
            for u in topology.nodes_per_layer[topology.layers-1]:
                model.addConstr(d[u] == 1)

            # constraint (1)
            for (i, v) in sample_nonterminal_pairs:
                if v == topology.root_node:
                    model.addConstr(w_p[(i, v)] + w_n[(i, v)] == 1)
                else:
                    model.addConstr(w_p[(i, v)] + w_n[(i, v)] == gurobipy.quicksum(z[(i, s, u, v)]
                            for (s, u, vv) in topology.arcs_arriving_at_node[v]))

            # constraints (2) and (3)
            for (i, u) in sample_nonterminal_pairs:
                model.addConstr(w_n[(i, u)] == gurobipy.quicksum(z[(i, "-", u, v)]
                        for (s, uu, v) in topology.neg_arcs_departing_node[u]))
                model.addConstr(w_p[(i, u)] == gurobipy.quicksum(z[(i, "+", u, v)]
                        for (s, uu, v) in topology.pos_arcs_departing_node[u]))

            # constraints (4) and (5)
            for (i, l) in sample_layer_pairs:
                if l == topology.layers - 1:
                    continue
                model.addConstr(gurobipy.quicksum(w_n[(i, u)] for u in topology.nodes_per_layer[l])
                        <= 1 - lambda_var[(i, l)])
                model.addConstr(gurobipy.quicksum(w_p[(i, u)] for u in topology.nodes_per_layer[l])
                        <= lambda_var[(i, l)])

            # constraint (6)
            for l in range(topology.layers - 1):
                for u in topology.nodes_per_layer[l]:
                    model.addConstr(d[u] == gurobipy.quicksum(y[arc]
                            for arc in topology.pos_arcs_departing_node[u]))
                    model.addConstr(d[u] == gurobipy.quicksum(y[arc]
                            for arc in topology.neg_arcs_departing_node[u]))
            
            # constraint (7)
            for l in range(1, topology.layers - 1):
                for v in topology.nodes_per_layer[l]:
                    model.addConstr(d[v] <= gurobipy.quicksum(y[arc]
                            for arc in topology.arcs_arriving_at_node[v]))

            # constraint (8)
            for l in range(topology.layers - 1):
                for u in topology.nodes_per_layer[l]:
                    for (s, uu, v) in topology.pos_arcs_departing_node[u]:
                        assert s == "+" and uu == u
                        model.addConstr(y[("+", u, v)] + y[("-", u, v)] <= d[v])
                        # constraints (9) and (10)
                        for i in range(data.train_n):
                            model.addConstr(z[(i, "+", u, v)] <= y[("+", u, v)])
                            model.addConstr(z[(i, "-", u, v)] <= y[("-", u, v)])

            # constraints (13) and (14)
            for l in range(topology.layers - 1):
                for v in topology.nodes_per_layer[l]:
                    for i in range(data.train_n):
                        model.addConstr((w_n[(i, v)] == 1) >>
                                (gurobipy.quicksum(a[v][f]*data.train_X[i][f]
                                for f in data.features) + cfg.epsilon <= b[v]))
                        model.addConstr((w_p[(i, v)] == 1) >>
                                (gurobipy.quicksum(a[v][f]*data.train_X[i][f]
                                for f in data.features) >= b[v]))

            # constraint (17)
            for (i, v) in sample_terminal_pairs:
                model.addConstr(w_t[(i, v)] == gurobipy.quicksum(z[(i, s, u, v)]
                        for (s, u, vv) in topology.arcs_arriving_at_node[v]))

            # note: topology.internal_nodes does _not_ include root_node
            assert len(topology.internal_nodes) > 0

            # objective function (18)
            model.setObjective(gurobipy.quicksum(w_t[(i, v)]*assignment_cost[(i, v)]
                    for (i, v) in sample_terminal_pairs)/data.train_n + alpha*gurobipy.quicksum(d[v]
                    for v in topology.internal_nodes)/len(topology.internal_nodes))

            if sym_break:
                # symmetry-breaking constraints
                # constraint (11)
                for l in range(topology.layers - 1):
                    for u in topology.nodes_per_layer[l]:
                        for (s, uu, v) in topology.pos_arcs_departing_node[u]:
                            assert s == "+" and uu == u
                            model.addConstr(y[("-", u, v)] + gurobipy.quicksum(y[("+", u, w)] for
                                    (s,uuu,w) in topology.pos_arcs_departing_node[u] if w<=v) <= 1)
                # constraint (12)
                for l in range(1, topology.layers - 1):
                    for u in topology.nodes_per_layer[l]:
                        for v in topology.nodes_per_layer[l]:
                            if u < v:
                                model.addConstr(gurobipy.quicksum(y[arc]
                                        for arc in topology.arcs_arriving_at_node[u]) >=
                                        gurobipy.quicksum(y[arc]
                                        for arc in topology.arcs_arriving_at_node[v]))

            """
            # constraint (20)
            for l in range(1, topology.layers - 1):
                for v in topology.nodes_per_layer[l]:
                    model.addConstr(gurobipy.quicksum(z[(i, s, u, v)]
                            for (s, u, vv) in topology.arcs_arriving_at_node[v]
                            for i in range(data.train_n)) >= S*data.train_n*d[v])
            """

            if force_tree:
                # force y design variables to conform to a tree
                for l in range(1, topology.layers - 1):
                    for v in topology.nodes_per_layer[l]:
                        model.addConstr(gurobipy.quicksum(y[arc]
                                for arc in topology.arcs_arriving_at_node[v]) <= 1)

            model.update()

            # Set various solver parameters
            model.setParam(GRB.Param.TimeLimit, cfg.time_limit)
            model.setParam(GRB.Param.FeasibilityTol, cfg.solver_feas_tol)
            model.setParam(GRB.Param.IntFeasTol, cfg.solver_int_tol)
            model.setParam(GRB.Param.OptimalityTol, cfg.solver_opt_tol)
            model.setParam(GRB.Param.Threads, 1)
            model.setParam('OutputFlag', True)
            if initial_solution is not None:
                initial_solution.obj_val = initial_solution.objective_value(alpha,
                        len(topology.internal_nodes))
                print("initial solution available with cost", initial_solution.obj_val)
                model.setParam(GRB.Param.Cutoff, 1.01*initial_solution.obj_val)

            print(model.getParamInfo(GRB.Param.FeasibilityTol))
            print(model.getParamInfo(GRB.Param.IntFeasTol))
            print(model.getParamInfo(GRB.Param.OptimalityTol))

            # This callback keeps track of when the best solution was found
            def time_last_sol(model, where):
                if where == GRB.Callback.MIPSOL:
                    global best_solution_val
                    global wall_time_of_solution
                    this_solution_val = model.cbGet(GRB.Callback.MIPSOL_OBJ)
                    if best_solution_val is None or best_solution_val > this_solution_val:
                        best_solution_val = this_solution_val
                        wall_time_of_solution = time.time()

            model.optimize(time_last_sol)       # solve MILP

            # SAVE RESULT IN Solution object
            if model.SolCount > 0:
                if model.status == GRB.OPTIMAL:
                    solver_optimal += 1
                elif model.status == GRB.TIME_LIMIT:
                    solver_timeout_with_sol += 1
                else:
                    print("dbg: unknown solver status code")
                print("dbg: solver ok/timeout(sol)/timeout(no sol)/infeasible: "
                        "{0}/{1}/{2}/{3}".format(solver_optimal, solver_timeout_with_sol,
                        solver_timeout_no_sol, solver_infeasible))
                self.solution = Solution(data, topology)
                for v in topology.nodes:
                    assert d[v].X <= 2*cfg.solver_int_tol or d[v].X >= 1-2*cfg.solver_int_tol
                    if d[v].X >= 0.9:
                        self.solution.used_nodes.add(v)
                        if cfg.verbose:
                            print("Node",v,"is used in solution")
                for l in range(topology.layers-1):
                    for v in topology.nodes_per_layer[l]:
                        self.solution.node_hyperplane[v] = [a[v][i].X for i in data.features]
                        self.solution.node_intercept[v] = b[v].X
                        for (s,u,w) in topology.pos_arcs_departing_node[v]:
                            assert (y[(s,u,w)].X <= 2*cfg.solver_int_tol
                                    or y[(s,u,w)].X >= 1-2*cfg.solver_int_tol)
                            if y[(s,u,w)].X >= 0.9:
                                self.solution.node_positive_arc[v] = w
                                if cfg.verbose:
                                    print("Node",v,"connects positively with",w,"in solution")
                                    print(" Hyperplane:", self.solution.node_hyperplane[v])
                                    print(" Intercept:", self.solution.node_intercept[v])
                        for (s,u,w) in topology.neg_arcs_departing_node[v]:
                            assert (y[(s,u,w)].X <= 2*cfg.solver_int_tol
                                    or y[(s,u,w)].X >= 1-2*cfg.solver_int_tol)
                            if y[(s,u,w)].X >= 0.9:
                                self.solution.node_negative_arc[v] = w
                                if cfg.verbose:
                                    print("Node",v,"connects negatively with",w,"in solution")
                for v in topology.node_class:
                    self.solution.node_class[v] = topology.node_class[v]
                    if cfg.verbose:
                        print("Node",v,"is assigned class",topology.node_class[v], "in sol")
                self.solution.training_accuracy()
                self.solution.optimal = (model.status == GRB.OPTIMAL)
                self.solution.mip_gap = model.getAttr("MIPGap")
                self.solution.obj_val = model.objVal
                self.solution.obj_lb = model.getAttr("ObjBoundC")
                self.solution.bb_nodes = model.getAttr("NodeCount")
                self.solution.best_solution_time = wall_time_of_solution - start_time
                if model.status == GRB.OPTIMAL and model.objVal > initial_solution.obj_val:
                    print("warning: heuristic solution (cost", initial_solution.obj_val,
                            ") is better than 'optimal' model solution (cost", model.objVal, ")")
            else:       # else, if solver cannot find a solution
                if model.status == GRB.INFEASIBLE:
                    solver_infeasible += 1
                elif model.status == GRB.TIME_LIMIT:
                    solver_timeout_no_sol += 1
                else:
                    print("dbg: unknown solver status code")
                print("dbg: solver ok/timeout(sol)/timeout(no sol)/infeasible: "
                        "{0}/{1}/{2}/{3}".format(solver_optimal, solver_timeout_with_sol,
                        solver_timeout_no_sol, solver_infeasible))
                print("Solver did not produce any solution. Status =", model.status)
                print("returning heuristic solution")
                initial_solution.obj_lb = model.getAttr("ObjBoundC")
                initial_solution.mip_gap = 1 - initial_solution.obj_lb/initial_solution.obj_val
                initial_solution.best_solution_time = 0
                initial_solution.optimal = False
                self.solution = initial_solution

